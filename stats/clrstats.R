# Clrbrain stats in R
# Author: David Young, 2018

library("gee")
library("plotly")
library("ggplot2")

# statistical models to use
kModel = c("logit", "linregr", "gee")
# measurements, which correspond to columns in main data frame
kMeas = c("Vol", "Dens", "Nuclei")
kStatsPathIn <- "../vols_by_sample.csv"
kStatsPathOut <- "../vols_stats.csv"
kRegionIDsPath <- "../region_ids.csv"

fitModel <- function(model, vals, genos, sides, ids=NULL) {
	# Fit data with the given model.
	#
	# Args:
	#   model: Model to use, corresponding to one of kModel.
	#   vals: Main independent variable.
	#   genos: Genotypes vector.
	#   sides: Vector indicated which side the given values is on, eg 
	#     corresponding to left or right
	#   ids: Vector of sample IDs; defaults to NULL.
	
	fit <- NULL
	if (model == kModel[1]) {
		# logistic regression
		fit <- glm(genos ~ vals * sides, family=binomial)
		print(summary.glm(fit))
	} else if (model == kModel[2]) {
		# linear regression
		fit <- lm(vals ~ genos * sides)
		print(summary.lm(fit))
	} else if (model == kModel[3]) {
		# generalized estimating equations
		fit <- gee(
			genos ~ vals * sides, ids, corstr="exchangeable", family=binomial())
	} else {
		cat("Sorry, model", model, "not found\n")
	}
	return(fit)
}

statsByCols <- function(df, col.start, model) {
	# Calculates statistics for columns starting with the given string using 
	# the selected model.
	#
	# Values of 0 will be ignored. If all values for a given vector are 0, 
	# statistics will not be computed.
	#
	# Args:
	#   df: Data frame with columns for Genos, Sides, and names starting with 
	#     col.start.
	#   col.start: Columns starting with this string will be included.
	#   model: Model to use, corresponding to one of kModel.
	
	# filter cols only starting with search string
	cols <- names(df)[grepl(col.start, names(df))]
	for (name in cols) {
		# filter out values of 0, using as mask for corresponding columns
		nonzero <- df[[name]] > 0
		cat("---------------------------\n")
		if (any(nonzero)) {
			vals <- df[[name]][nonzero]
			genos <- df$Geno[nonzero]
			sides <- df$Side[nonzero]
			cat(name, ": ", vals, "\n")
			fit <- fitModel(model, vals, genos, sides, ids)
			hist(vals)
		} else {
			cat(name, ": no non-zero samples found\n\n")
		}
	}
}

statsByRegion <- function(df, col, model) {
	# Calculates statistics given by region for columns starting with the given 
	# string using the selected model.
	#
	# Values of 0 will be ignored. If all values for a given vector are 0, 
	# statistics will not be computed.
	#
	# Args:
	#   df: Data frame with columns for Genos, Sides, Region, and name given by 
	#     col.
	#   col: Column from which to find main stats.
	#   model: Model to use, corresponding to one of kModel.
	
	# find all regions
	regions <- unique(df$Region)
	cols <- c("Region", "Stats")
	stats <- data.frame(matrix(nrow=length(regions), ncol=length(cols)))
	names(stats) <- cols
	for (i in seq_along(regions)) {
		region <- regions[i]
		# filter data frame for the given region
		df.region <- df[df$Region == region, ]
		# generate mask to filter out values of 0
		nonzero <- df.region[[col]] > 0
		cat("---------------------------\n")
		stats$Region[i] <- region
		if (any(nonzero)) {
			# filter each column within region for rows with non-zero values
			vals <- df.region[[col]][nonzero]
			genos <- df.region$Geno[nonzero]
			sides <- df.region$Side[nonzero]
			ids <- df.region$Sample[nonzero]
			cat("Region", region, ": ", vals, "\n")
			
			# apply stats and store in stats data frame, using list to allow 
			# arbitrary size
			fit <- fitModel(model, vals, genos, sides, ids)
			stats$Stats[i] <- list(summary(fit)$coefficients)
			
			# show histogram to check for parametric distribution
			hist(vals)
		} else {
			# ignore region if all values 0, leaving entry for region as NA
			cat(region, ": no non-zero samples found\n\n")
		}
	}
	return(stats)
}

filterStats <- function(stats) {
	# Filter regional statistics to remove \code{NA}s and gather the most 
	# pertinent statistical values.
	#
	# Args:
	#   stats: Data frame generated by \code{\link{statsByRegion}}.
	#
	# Returns:
	#   Filtered data frame with columns for Region, Effect, and p.
	
	cols <- c("Region", "Effect", "p")
	non.na <- !is.na(stats$Stats)
	stats.filt <- stats[non.na, ]
	filtered <- data.frame(matrix(nrow=nrow(stats.filt), ncol=length(cols)))
	names(filtered) <- cols
	filtered$Region <- stats.filt$Region
	for (i in 1:nrow(stats.filt)) {
		# get coefficients, stored in one-element list
		if (is.na(stats.filt$Stats[i])) next
		stats.coef <- stats.filt$Stats[i][[1]]
		# effect and p-value from first non-intercept row
		filtered$Effect[i] <- stats.coef[2, 1]
		filtered$p[i] <- stats.coef[2, 4]
	}
	return(filtered)
}

volcanoPlot <- function(stats, meas, y.thresh=NULL) {
	# Generate a volcano plot.
	#
	# Args:
	#   stats: Data frame generated by \code{\link{filterStats}}.
	x <- stats$Effect
	y <- -1 * log(stats$p)
	plot(
		x, y, main=paste(meas, "Differences"), xlab="Effects", ylab="-log(p)",
		type="p", col="blue", pch=16)
	x.lbl <- x
	y.lbl <- y
	lbls <- paste(stats$Region, stats$RegionName, sep="\n")
	if (!is.null(y.thresh)) {
		y.high <- y > y.thresh
		x.lbl <- x[y.high]
		y.lbl <- y[y.high]
		lbls <- lbls[y.high]
	}
	text(x.lbl, y.lbl, label=lbls, cex=0.3, pos=3)
	# plot_ly(data=stats, x=x, y=y)
	#g <- ggplot(data=stats, aes(x=x, y=y)) + geom_point(size=2)
	# ggplotly(g, tooltip=c("Region"))
	#print(g)
}

calcVolStats <- function(path.in, path.out, meas, model, region.ids) {
	# Calculate volumetric stats from the given CSV file.
	#
	# Args:
	#   path.in: Path from which to load CSV to calculate stats, assumed to be 
	#     generated by \code{clrbrain.stats.regions_to_pandas} Python function.
	#   path.out: Path to output CSV file.
	#   meas: Column from which to generate stats, which should be one of 
	#     \code{\link{kMeas}}.
	#   model: Model type to use for stats, which should be one of 
	#     \code{\link{kModel}}.
	#
	# Returns:
	#   Filtered data frame from \code{\link{filterStats}}.
	
	# load CSV file output by Clrbrain Python stats module
	df <- read.csv(path.in)
	print.data.frame(df)
	cat("\n\n")
	
	# calculate stats, filter out NAs and extract effects and p-values
	stats <- statsByRegion(df, meas, model)
	stats.filtered <- filterStats(stats)
	stats.filtered <- merge(stats.filtered, region.ids, by="Region")
	print(stats.filtered)
	write.csv(stats.filtered, path.out)
	return(stats.filtered)
}

meas <- kMeas[2]
region.ids <- read.csv(kRegionIDsPath)
if (file.exists(kStatsPathOut)) {
	stats <- read.csv(kStatsPathOut)
} else {
	stats <- calcVolStats(
		kStatsPathIn, kStatsPathOut, meas, kModel[1], region.ids)
}
volcanoPlot(stats, meas, y.thresh=2)
