# Stats for Clrbrain
# Author: David Young, 2018
"""Stats calculations and text output for Clrbrain.

Attributes:
"""

import copy
import csv
import numpy as np
import pandas as pd
from scipy import stats

from clrbrain import config

def _volumes_mean_sem(group_dict, key_mean, key_sem, vals, mask):
    """Calculate the mean and standard error of the mean (SEM), storing them 
    in the dictionary.
    
    Values are filtered by ``mask``, and empty (ie near-zero or None) volumes 
    are excluded as well.
    
    Args:
        group_dict: Dictionary where the SEM will be stored.
        key_mean: Key at which the mean will be stored.
        key_sem: Key at which the SEM will be stored.
        vals: Values from which to calculate.
        mask: Boolean array corresponding to ``vals`` of values to keep.
    """
    # convert to Numpy array to filter by make
    vals = np.array(vals)
    if mask is not None:
        vals = vals[mask]
    print("group vals raw: {}, mask: {}, n: {}".format(vals, mask, vals.size))
    
    # further prune to remove None or near-zero values (ie no volume found)
    vals = vals[vals != None] # TODO: check if actually encounter None vals
    vals = vals[vals > config.POS_THRESH]
    mean = np.mean(vals)
    sem = stats.sem(vals)
    print("mean: {}, err: {}, n after pruning: {}".format(mean, sem, vals.size))
    group_dict[key_mean].append(mean)
    group_dict[key_sem].append(sem)

def volume_stats(volumes_dict, densities, groups=[""], unit_factor=1.0):
    """Generate stats for volumes and densities by region and groups.
    
    Args:
        volumes_dict: Dictionary of volumes as generated by 
            :func:``register.volumes_by_id`` or 
            :func:``register.group_volumes``, including values from 
            individual or grouped experiments, respectively.
        densities: True if densities should be extracted and displayed from 
            the volumes dictionary; defaults to False.
        groups: List of groupings for each experiment. List length should be 
            equal to the number of values stored in each label's list in 
            ``volumes_dict``. Defaults to a list with an empty string, in 
            which case each label's value will be assumed to be a scalar 
            rather than a list of values.
        unit_factor: Factor by which volumes will be divided to adjust units; 
            defaults to 1.0.
    
    Returns:
        Tuple of ``group_dict``, ``names``, ``mean_keys``, ``err_keys``, and 
        ``measurement_keys``.
        ``group_dict`` is a dictionary with group names as keys. Each value is 
        another dictionary with ``meausurement_keys`` as keys, such as 
        "volumes" or "densities". Values are in turn additional dictionaries 
        with ``mean_keys`` as keys for sub-groups, such as "right" or "left", 
        and ``err_keys`` as keys for error values, such "SEM_of_th_right" 
        or "SEM_of_the_left". These values are 2-dimensional lists in the 
        format, 
        ``[[name0_val0, name0_val2, ...], [name1_val0, name2_val1, ...], ...]``,
        where ``names`` correspond to these values. If only one sub-list is 
        given, such as for individual experiments rather than a group of 
        experiments, error values are assumed to be None or empty lists.
    """
    # "side" and "mirrored" for opposite side (R/L agnostic)
    SIDE = "side"
    MIR = "mirrored"
    SIDE_SEM = SIDE + "_sem"
    MIR_SEM = MIR + "_sem"
    VOL = "volume"
    DENS = "density"
    multiple = groups is not None
    groups_unique = np.unique(groups)
    groups_dict = {}
    for group in groups_unique:
        print("Finding volumes and densities for group {}".format(group))
        # dictionary of mean and SEM arrays for each side, which will be 
        # populated in same order as experiments in volumes_dict
        vol_group = {SIDE: [], MIR: [], SIDE_SEM: [], MIR_SEM: []}
        dens_group = copy.deepcopy(vol_group)
        groups_dict[group] = {VOL: vol_group, DENS: dens_group}
        group_mask = np.array(groups) == group if multiple else None
        for key in volumes_dict.keys():
            # find negative keys based on the given positive key to show them
            # side-by-side
            if key >= 0:
                # get volumes in the given unit, which are scalar for 
                # individual image, list if multiple images
                vol_side = np.divide(
                    volumes_dict[key][config.VOL_KEY], unit_factor)
                vol_mirrored = np.divide(
                    volumes_dict[-1 * key][config.VOL_KEY], unit_factor)
                # store vol and SEMs in vol_group
                if isinstance(vol_side, np.ndarray):
                    # for multiple experiments, store mean and error
                    _volumes_mean_sem(
                        vol_group, SIDE, SIDE_SEM, vol_side, group_mask)
                    _volumes_mean_sem(
                        vol_group, MIR, MIR_SEM, vol_mirrored, group_mask)
                else:
                    # for single experiment, store only vol
                    vol_group[SIDE].append(vol_side)
                    vol_group[MIR].append(vol_mirrored)
                
                if densities:
                    # calculate densities based on blobs counts and volumes
                    blobs_side = volumes_dict[key][config.BLOBS_KEY]
                    blobs_mirrored = volumes_dict[-1 * key][config.BLOBS_KEY]
                    print("id {}: blobs R {}, L {}".format(
                        key, blobs_side, blobs_mirrored))
                    density_side = np.nan_to_num(
                        np.divide(blobs_side, vol_side))
                    density_mirrored = np.nan_to_num(
                        np.divide(blobs_mirrored, vol_mirrored))
                    if isinstance(density_side, np.ndarray):
                        # density means and SEMs, storing the SEMs
                        _volumes_mean_sem(
                            dens_group, SIDE, SIDE_SEM, density_side, 
                            group_mask)
                        _volumes_mean_sem(
                            dens_group, MIR, MIR_SEM, density_mirrored, 
                            group_mask)
                    else:
                        dens_group[SIDE].append(density_side)
                        dens_group[MIR].append(density_mirrored)
    names = [volumes_dict[key][config.ABA_NAME] 
             for key in volumes_dict.keys() if key >= 0]
    return groups_dict, names, (MIR, SIDE), (MIR_SEM, SIDE_SEM), (VOL, DENS)

def volume_stats_to_csv(vol_stats, path, groups=[""]):
    """Export volume mean stats to CSV file.
    
    Args:
        vol_stats: Dictionary of volume mean/error stats as given by 
            :func:``volume_stats``.
        path: Path to output CSV file. If the filename does not end with .csv, 
            this extension will be appended.
        groups: List of groups; defaults to a list with an empty string, which 
            is the default for ``vol_stats`` with no group, including an 
            individual sample.
    """
    # unpack volume stats
    groups_dict, names, means_keys, sem_keys, meas_keys = vol_stats
    ext = ".csv"
    if not path.endswith(ext): path += ext
    
    # build lists of all values for the given measurements, with an element 
    # for each group-subgroup combo 
    # (eg [WT_R_vols, WT_L_vols, het_R_vols, het_L_vols])
    vols = []
    dens = []
    errs_vols = []
    errs_dens = []
    bar_colors = []
    header = ["Region"]
    groups_unique = np.unique(groups)
    for group_name in groups_unique:
        group = groups_dict[group_name]
        for means_key in means_keys:
            vols.append(group[meas_keys[0]][means_key])
            dens.append(group[meas_keys[1]][means_key])
        for sem_key in sem_keys:
            errs_vols.append(group[meas_keys[0]][sem_key])
            errs_dens.append(group[meas_keys[1]][sem_key])
        # add a set of headers for each group
        header.extend("{0}_vol_L,{0}_vol_sem_L,{0}_density_L,{0}_density_sem_L,"
                      "{0}_vol_R,{0}_vol_sem_R,{0}_density_R,{0}_density_sem_R"
                      .format(group_name).split(","))
    
    with open(path, "w", newline="") as csv_file:
        stats_writer = csv.writer(csv_file, delimiter=",")
        stats_writer.writerow(header)
        
        # output row for each name, where names list matches each vol list 
        # (i) within vols, and each vol list is for a separate group (j)
        for i in range(len(names)):
            row = [names[i]]
            for j in range(len(vols)):
                vol = vols[j][i]
                err_vol = None
                if errs_vols[j] and len(errs_vols[j]) > 0:
                    err_vol = errs_vols[j][i]
                den = dens[j][i]
                err_den = None
                if errs_dens[j] and len(errs_dens[j]) > 0:
                    err_den = errs_dens[j][i]
                row.extend([str(vol), str(err_vol), str(den), str(err_den)])
            print(row)
            stats_writer.writerow(row)

def volumes_to_csv(volumes_dict, path, groups=[""], unit_factor=1.0):
    """Export volumes from each sample to Pandas format and CSV file.
    
    Args:
        volumes_dict: Dictionary of volumes as generated by 
            :func:``register.volumes_by_id`` or 
            :func:``register.group_volumes``, including values from 
            individual or grouped experiments, respectively.
        path: Path to output CSV file. If the filename does not end with .csv, 
            this extension will be appended.
        groups: List of groupings for each experiment. List length should be 
            equal to the number of values stored in each label's list in 
            ``volumes_dict``. Defaults to a list with an empty string, in 
            which case each label's value will be assumed to be a scalar 
            rather than a list of values.
        unit_factor: Factor by which volumes will be divided to adjust units; 
            defaults to 1.0.
    
    Returns:
        Pandas ``DataFrame`` with volume and density as separate columns for 
        each region, with one line per sample per side. Eg: 
        ```
        Sample, Geno, Side, Vol_01, Dens_01, Vol_02, Dens_02, ...
        0, 0, L, 1.1, 0.3, 1.2, 0.2, ...
        0, 0, R, 0.9, 0.2, 1.1, 0.2, ...
        1, 0, L, 1.0, 0.3, 1.1, 0.3, ...
        ```
    """
    header = ["Sample", "Geno", "Side"]
    num_samples = len(groups)
    samples = list(range(num_samples)) * 2
    genos = groups * 2
    sides = ["L"] * num_samples
    sides.extend(["R"] * num_samples)
    vol_dens = []
    for key in volumes_dict.keys():
        # find negative keys based on the given positive key to group them
        if key >= 0:
            header.append("Vol_{}".format(key))
            header.append("Dens_{}".format(key))
            # get volumes in the given unit, which are scalar for 
            # individual image, list if multiple images
            vol_side = np.divide(
                volumes_dict[key][config.VOL_KEY], unit_factor)
            vol_mirrored = np.divide(
                volumes_dict[-1 * key][config.VOL_KEY], unit_factor)
            # calculate densities based on blobs counts and volumes
            blobs_side = volumes_dict[key][config.BLOBS_KEY]
            blobs_mirrored = volumes_dict[-1 * key][config.BLOBS_KEY]
            density_side = np.nan_to_num(np.divide(blobs_side, vol_side))
            density_mirrored = np.nan_to_num(
                np.divide(blobs_mirrored, vol_mirrored))
            
            # concatenate vol/dens from each side into 1d list and interleave 
            # in master list
            vols = vol_side.tolist()
            vols.extend(vol_mirrored.tolist())
            vol_dens.append(vols)
            density = density_side.tolist()
            density.extend(density_mirrored.tolist())
            vol_dens.append(density)
    
    # pool lists and add to Pandas data frame
    volumes_dataset = list(zip(samples, genos, sides, *vol_dens))
    data_frame = pd.DataFrame(data=volumes_dataset, columns=header)
    ext = ".csv"
    if not path.endswith(ext): path += ext
    data_frame.to_csv(path, index=False)
    print("exported volume data per sample to CSV at {}".format(path))
    return data_frame

if __name__ == "__main__":
    print("Starting Clrbrain stats...")
